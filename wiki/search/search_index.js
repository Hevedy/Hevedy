var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Hevedy Docs","text":"<p>Welcome to Hevedy Docs, the central hub for all documentation related to our suite of powerful tools designed to enhance your creative workflows. Here you\u2019ll find comprehensive guides, tutorials, and references for both Purpleprint\u2014our versatile Unreal Engine plugin suite\u2014and Purple Image, an advanced standalone image editing and texture management toolkit.  </p>"},{"location":"index.html#what-youll-find-here","title":"What You\u2019ll Find Here","text":"<ul> <li> <p>Purpleprint: A collection of modular plugins built for Unreal Engine, offering utilities ranging from core math libraries to audio management, procedural asset placement, and spline-based path creation. These tools are designed to streamline level design, audio ambiance, and environment setup.  </p> </li> <li> <p>Purple Image: A robust image editing suite packed with tools for texture processing, color palette creation, batch operations, and workspace organization. Whether you\u2019re optimizing game textures or crafting color schemes, Purple Image accelerates your workflow with intuitive interfaces and automation features.  </p> </li> </ul> <p>Dive into each section for detailed information on installation, usage, and best practices, along with helpful tips to get the most out of these tools. We\u2019re committed to supporting your creative projects with reliable, efficient, and easy-to-use solutions.  </p> <p>Happy developing and designing!  </p>"},{"location":"purple-image/index.html","title":"Purple Image Documentation","text":"<p>Welcome to the official Purple Image documentation! This guide provides an overview of our powerful suite of tools designed to simplify and accelerate your workflow in image editing, texture management, and color design.</p>"},{"location":"purple-image/index.html#tools-overview","title":"Tools Overview","text":""},{"location":"purple-image/index.html#editor","title":"Editor","text":"<p>The Editor is your all-in-one workspace for combining, splitting, and editing textures in real-time. It allows you to package textures optimized for performance with a simple drag-and-drop interface. Quickly adjust colors, generate LUT tables, and share presets seamlessly to improve your game or design projects.</p>"},{"location":"purple-image/index.html#batcher","title":"Batcher","text":"<p>The Batcher automates the processing of large batches of images. It can convert entire folders, package color channels efficiently, and optimize textures to reduce load times and boost performance. This tool is essential for managing large-scale texture workflows.</p>"},{"location":"purple-image/index.html#palette","title":"Palette","text":"<p>The Palette tool enables you to pick and create custom color palettes for any project. Whether you're designing for the web, creating filters, or working on digital art, Palette helps you craft harmonious color schemes and export them to your favorite design tools.</p>"},{"location":"purple-image/index.html#board","title":"Board","text":"<p>Board acts as your virtual reference desktop. Arrange multiple images and use them as guides for drawing, painting, or designing. It's a flexible workspace that helps keep your inspirations and references visible and organized while you work.</p>"},{"location":"purple-image/batcher.html","title":"Batch Tools","text":"<p>The Batcher automates repetitive tasks for large sets of images, ensuring consistent processing and efficiency:  </p> <ul> <li> <p>Batch Combiner: Merge batches of images channel-wise, packaging textures in bulk for better performance and streamlined asset management.  </p> </li> <li> <p>Batch Editor: Apply edits across multiple images at once, such as color adjustments or compression settings.  </p> </li> <li> <p>Batch Splitter: Divide large sets of textures into individual channels in bulk, useful for workflows requiring channel-specific manipulation or optimization.  </p> </li> </ul>"},{"location":"purple-image/board.html","title":"Image Board","text":"<p>The Board acts as a flexible reference canvas to improve creative workflows:  </p> <ul> <li> <p>Image Management: Import multiple reference images to organize your visual workspace.  </p> </li> <li> <p>Basic Controls: Rotate, align, and adjust the transparency (alpha) of each image independently.  </p> </li> <li> <p>Workspace Cloud: Arrange images freely across the canvas to build a 'cloud' of references, ideal for sketching, painting, or design work where visual inspiration needs to remain accessible.  </p> </li> </ul>"},{"location":"purple-image/color-palette.html","title":"Color Palette","text":"<p>The Palette tool provides extensive color management capabilities aimed at designers and developers:  </p> <ul> <li> <p>Color Selectors: Choose colors through multiple modes including RGB, HSV, and Hex codes, suitable for web design, digital art, and game development.  </p> </li> <li> <p>Palette Export: Export your created palettes in formats compatible with popular design tools such as GIMP and Photoshop.  </p> </li> <li> <p>Drag &amp; Drop Importer: Import images by dragging and dropping them into the tool to automatically extract dominant colors or pixel-based color data.  </p> </li> <li> <p>Scriptable Color Generator: Generate colors programmatically using scripting support for multiple programming languages, enabling seamless integration into automated pipelines or procedural generation workflows.  </p> </li> </ul> <p>Work as common color selector but give you different suggestions of color with different light, intensity and shading.  You can get the RGB, sRGB value or the Hex values that can be used in the game engines color selectors, in websites or even in other image apps. Allow you to create a smaller window and overlap other apps, in this way you can use with other image tools. Can copy the values directly to the clipboard in this way you only need to paste the final value in your image tool, or select the color from your image tool in the window.</p> <p>This tool allow you too to select the color by sRGB and return the value automatic.</p>"},{"location":"purple-image/color-palette.html#color-selector","title":"Color Selector","text":"<p>Pick the colors you want, save them into a palette or automatically copy them to any other software into your clipboard.</p> <p> sadfsfsfsdfsfdsfds</p> <p></p> <p></p> <p></p> <p></p> <p>Image caption</p>"},{"location":"purple-image/color-palette.html#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"purple-image/editor.html","title":"Editor","text":"<p>The Editor is a powerful and versatile image editing workspace with multiple specialized features:  </p> <ul> <li> <p>LUT Editor: A full-featured LUT (Look-Up Table) editor with precise controls to manipulate color grading, contrast, brightness, and more. Create and export custom LUTs for game engines or other creative applications.  </p> </li> <li> <p>Channel Splitter: Extract individual color channels (e.g., Red, Green, Blue, Alpha) from your images, allowing for detailed per-channel editing.  </p> </li> <li> <p>Channel Combiner: Combine separate grayscale images representing different color channels into a single packed texture, optimizing performance and texture memory usage.  </p> </li> </ul> <p></p> <p>The packager tool can help you to combine or split images in layers saving until x2 times of memory per texture for your games.</p> <p>The tool include 5 functions combine, split, convert, package and batch.</p> <p>Note: You can combine or split a maximun of 4 layers per texture ( R G B A ).</p> <p>In difference to the common paid and free image stuites and other image tools, the LUT Editor included in the \"Purpleprint - Image Tools\" is the faster way to create LUT files or just edit the images in real-time for game engines Post-processing or video editing using a set of real-time parameter.</p> <p>This tool give you the control over all the parameters in real-time, while all the common paid tools need to bake the results of each parameter.</p> <p>You can save too the values in a file, in this way you never lost and can replicate the results in different images, just loading it.</p>"},{"location":"purple-image/editor.html#layers-combiner","title":"Layers Combiner","text":"<p>This tool can be used to combine up to 8 layers from individual images into a single image.</p> <p></p> <p>Since the version 1.5.2 comes with a Filtered &amp; Unfiltered option output.</p> <p></p>"},{"location":"purple-image/editor.html#layers-splitter","title":"Layers Splitter","text":"<p>This one works the reverse way of the prior tool, allows to split a image in different images based on it's channels.</p> <p>The UI display a maximum of 4 at time, but you can choose each one display options individually.</p> <p></p>"},{"location":"purple-image/editor.html#layers-splitter-controls","title":"Layers Splitter Controls","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"purpleprint/index.html","title":"Purpleprint Suite for Unreal Engine","text":"<p>The Purpleprint Suite is a comprehensive collection of powerful plugins designed to enhance your Unreal Engine projects with modular, flexible tools.</p>"},{"location":"purpleprint/index.html#purpleprint-core","title":"Purpleprint Core","text":"<p>At the heart of the suite is Purpleprint Core, the essential foundation plugin. It provides multiple utility libraries including math functions, randomization tools, miscellaneous helpers, and platform-specific utilities. This core plugin serves as the base dependency for all other Purpleprint tools, ensuring seamless integration and robust functionality. Explore the repository and detailed documentation here: Purpleprint Core GitHub.</p>"},{"location":"purpleprint/index.html#purpleprint-audio","title":"Purpleprint Audio","text":"<p>A streamlined audio utility plugin offering handy classes and tools for sound management. One highlight is the Audio Spline actor, designed to play audio near the player along a spline \u2014 perfect for ambient sounds like rivers or wind, controlled with just a single point.</p>"},{"location":"purpleprint/index.html#purpleprint-placer","title":"Purpleprint Placer","text":"<p>This toolset includes several powerful placement utilities: Placer Area, Placer Spline, and Placer Array. They enable the random distribution and alignment of actors, static meshes, decals, and more throughout your level. Objects can be placed on walls, floors, or any surfaces you specify, giving you complete creative control over environmental detail.</p>"},{"location":"purpleprint/index.html#purpleprint-path","title":"Purpleprint Path","text":"<p>Focused on spline-based mesh placement, Purpleprint Path is tailored for creating roads, pathways, and similar elements. It builds on the placer concept but specializes in generating smooth, spline-driven mesh arrangements, ideal for roads or any elongated structures.</p>"},{"location":"purpleprint/audio/index.html","title":"Purpleprint Audio","text":"<p>Purpleprint Audio offers audio-related tools and classes to enhance sound implementation in your projects with minimal setup.  </p>"},{"location":"purpleprint/audio/index.html#main-feature","title":"Main Feature:","text":"<ul> <li>Audio Spline Actor: An actor that plays audio near the player following a spline path. This is perfect for environmental sounds such as flowing rivers, wind, or other ambient effects that move or stretch across a level. It supports easy control using just a single point on the spline.  </li> </ul> <p>This plugin simplifies creating dynamic and immersive audio environments with minimal complexity.  </p>"},{"location":"purpleprint/bridge/index.html","title":"Purpleprint Bridge","text":"<p>Purpleprint Bridge is a Blender add-on designed to export scene object data into a format compatible with Purpleprint Placer and other Unreal Engine-based tools.</p> <p>This tool enables quick and structured transfer of level design data from Blender to Unreal Engine pipelines, making it ideal for prototyping, layout planning, and mass placement of entities in-game.  </p>"},{"location":"purpleprint/bridge/index.html#download","title":"Download:","text":"<p>Github </p>"},{"location":"purpleprint/bridge/index.html#features","title":"Features:","text":"<ul> <li>\u2705 Exports only objects marked as visible for render.</li> <li>\ud83d\udeab Ignores Empty objects, but applies their world transforms to their children.</li> <li>\ud83e\udde0 Smart grouping: all instances of the same model use the same Type name.</li> <li>\ud83c\udf10 Exports world-space transforms: Location, Rotation (in degrees), and Scale.</li> <li>\ud83d\udd01 Recursively processes object hierarchies.</li> <li>\ud83d\udcc4 Output is compatible with Unreal Engine tools, such as Purpleprint Placer.</li> </ul>"},{"location":"purpleprint/bridge/index.html#field-breakdown","title":"\ud83d\udd0d Field Breakdown:","text":"<ul> <li>Name: Blender object name.</li> <li>Type: Object type and its mesh/model name.</li> <li>Location: Global position formatted as Unreal vector.</li> <li>Rotation: Global rotation in Unreal's <code>(Pitch, Yaw, Roll)</code> format.</li> <li>Scale: Global object scale.</li> </ul>"},{"location":"purpleprint/bridge/index.html#default-export-path","title":"\ud83d\uddc2 Default Export Path","text":"<p>By default, the <code>.csv</code> file is saved to:</p> <p><code>&lt;your_blendfile_directory&gt;/purpleprint_entities.csv</code></p> <p>You can choose a custom path in the panel, and it will be saved with your <code>.blend</code> project for future use.</p>"},{"location":"purpleprint/bridge/index.html#installation","title":"\ud83e\udded Installation","text":"<ol> <li>Download <code>PurpleprintBridge.py</code>.</li> <li>Open Blender and go to <code>Edit &gt; Preferences &gt; Add-ons</code>.</li> <li>Click Install, select the Python file, and enable the addon.</li> <li>Find the Export Tools panel in the 3D Viewport Sidebar (<code>N</code> key).</li> <li>Click \"Export Purple CSV\" to generate your <code>.csv</code> file.</li> </ol>"},{"location":"purpleprint/bridge/index.html#use-case","title":"\ud83d\udee0 Use Case","text":"<p>Purpleprint Bridge is perfect for:</p> <ul> <li>Level designers using Blender as a blocking/layout tool.</li> <li>Technical artists building automated import systems in Unreal.</li> <li>Anyone needing to export world-space transform data from Blender into readable <code>.csv</code> formats for runtime placement or instancing in Unreal.</li> </ul>"},{"location":"purpleprint/bridge/index.html#compatibility","title":"\u2705 Compatibility","text":"<ul> <li>Blender 4.0 and above</li> <li>Compatible with Unreal Engine 4 &amp; 5</li> <li>Output ready for tools like Purpleprint Core &amp; Purpleprint Placer</li> </ul>"},{"location":"purpleprint/bridge/index.html#license","title":"\ud83d\udcdc License","text":"<p>This project is licensed under the GNU General Public License v3.0.</p> <p>You are free to use, modify, and redistribute this code under the terms of the GPL.</p> <p>See the full license text in the <code>LICENSE</code> file or visit: \ud83d\udc49 https://www.gnu.org/licenses/gpl-3.0.html</p>"},{"location":"purpleprint/core/index.html","title":"Purpleprint Core","text":"<p>Purpleprint Core is the foundational plugin that all other Purpleprint plugins depend on. It provides essential libraries and utilities that simplify development and improve workflow across your projects.</p>"},{"location":"purpleprint/core/index.html#key-features","title":"Key Features:","text":"<ul> <li>Math Library: Collection of useful mathematical functions and helpers to simplify complex calculations.</li> <li>Random Library: Tools for generating random values and randomization utilities to enhance procedural generation.</li> <li>Miscellaneous Utilities: Various helper functions for common tasks, designed to save time and increase productivity.</li> <li>Platform Utilities: Functions to detect and handle platform-specific behavior or differences, ensuring compatibility and optimization.</li> </ul> <p>Explore the full source code and detailed documentation here: Purpleprint Core GitHub Repository</p>"},{"location":"purpleprint/core/api/purpleprint-core-camera-tracker-editor.html","title":"PurpleprintCoreCameraTrackerEditor.h","text":""},{"location":"purpleprint/core/api/purpleprint-core-camera-tracker-editor.html#classstruct-fpurpleprintcorecameratrackereditor","title":"Class/Struct: FPurpleprintCoreCameraTrackerEditor","text":"<ul> <li>\u274c <code>static FTransform GetLastCameraTransform();</code> </li> </ul> <ul> <li>\u274c <code>static FVector GetLastCameraLocation();</code> </li> </ul> <ul> <li>\u274c <code>static FRotator GetLastCameraRotation();</code> </li> </ul> <ul> <li>\u274c <code>static void SetLastCameraLocation(const FVector&amp; NewLocation);</code> </li> </ul> <ul> <li>\u274c <code>static void SetLastCameraRotation(const FRotator&amp; NewRotation);</code> </li> </ul>"},{"location":"purpleprint/core/api/purpleprint-core-math.html","title":"PurpleprintCoreMath.h","text":""},{"location":"purpleprint/core/api/purpleprint-core-math.html#classstruct-upurpleprintcoremath-inherits-from-ublueprintfunctionlibrary","title":"Class/Struct: UPurpleprintCoreMath (inherits from UBlueprintFunctionLibrary)","text":"<ul> <li>\u2705 <code>static float Cbrt( const float Value );</code>  Slower than Log2 but more accurate 1.0 / Loge(10)= 0.4342944f Missing from C++ lib so here are, the Degress operations Returns cube root</li> </ul> <ul> <li>\u2705 <code>static float OneLimit(const float Value);</code> </li> </ul> <ul> <li>\u2705 <code>static float OneMinus(const float Value);</code> </li> </ul> <ul> <li>\u2705 <code>static int32 NegateInt(const int32 Value);</code> </li> </ul> <ul> <li>\u2705 <code>static float Negate(const float Value);</code> </li> </ul> <ul> <li>\u2705 <code>static int32 ReverseInt(const int32 Value);</code> </li> </ul> <ul> <li>\u2705 <code>static float Reverse(const float Value);</code> </li> </ul> <ul> <li>\u274c <code>static double CalculateCameraHeightForArea(double DesiredWidthUU, float VerticalFOVDegrees);</code>  #if UE_VERSION_NEWER_THAN(5, 2, 0) #endif Cannot set a check for newer versions here, UFUNCTION isn't supported inside #if verison check</li> </ul> <ul> <li>\u2705 <code>static float CalculateCameraHeightForAreaFloat(float DesiredWidthUU, float VerticalFOVDegrees);</code> </li> </ul> <ul> <li>\u2705 <code>static FTransform TransformsAddMasked(const FTransform&amp; A, const FTransform&amp; B, bool bLocation = true, bool bRotation = true, bool bScale = false, bool bReturnFirst = true);</code> </li> </ul> <ul> <li>\u2705 <code>static FTransform TransformsSubMasked(const FTransform&amp; A, const FTransform&amp; B, bool bLocation = true, bool bRotation = true, bool bScale = false, bool bReturnFirst = true);</code> </li> </ul> <ul> <li>\u2705 <code>static FTransform TransformsMulMasked(const FTransform&amp; A, const FTransform&amp; B, bool bLocation = true, bool bRotation = true, bool bScale = false, bool bbReturnFirst = true);</code> </li> </ul> <ul> <li>\u2705 <code>static FTransform TransformsCombine(const FTransform&amp; A, const FTransform&amp; B);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector GetClosestPointOnSphereSurface(const FVector&amp; SphereCenter, float SphereRadius, const FVector&amp; TargetPoint);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector GetClosestPointOnDomeSurface(const FVector&amp; DomeCenter, float DomeRadius, const FVector&amp; TargetPoint);</code> </li> </ul> <ul> <li>\u2705 <code>static float SpringFloat(float Current, float Target, float&amp; Velocity, float Frequency, float Damping, float DeltaTime);</code> </li> </ul> <ul> <li>\u2705 <code>static bool FLinearColorNearEqual(const FLinearColor A, const FLinearColor B, const bool bIgnoreAlpha = true);</code> </li> </ul> <ul> <li>\u2705 <code>static float BoxPerimeter(const float SizeX, const float SizeY);</code> </li> </ul> <ul> <li>\u2705 <code>static float BoxDiagonal(const float SizeX, const float SizeY);</code> </li> </ul> <ul> <li>\u2705 <code>static float BoxSide(const float Diagonal);</code> </li> </ul> <ul> <li>\u2705 <code>static float VectorDistance(const FVector A, const FVector B);</code> </li> </ul> <ul> <li>\u2705 <code>static float Distance2D(const FVector2D A, const FVector2D B);</code> </li> </ul> <ul> <li>\u2705 <code>static float GetVectorsAngleRadiants(FVector A, FVector B);</code> </li> </ul> <ul> <li>\u2705 <code>static float GetVectorsAngleDegrees(FVector A, FVector B);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector GetPointOnLineAtDistance(FVector Start, FVector End, float Distance);</code> </li> </ul> <ul> <li>\u2705 <code>static float LerpLinearBounce(float Alpha);</code> </li> </ul> <ul> <li>\u2705 <code>static float LerpLinearBounceAuto(float&amp; Alpha, float Delta, float DeltaSpeed = 1.0f);</code>  Make callable because will return only once</li> </ul> <ul> <li>\u2705 <code>static int32 NormalizeInRangeRoulette(const int32 Value, const int32 Min, const int32 Max);</code>  Returns the float in range of min and max can cross up or down</li> </ul> <ul> <li>\u2705 <code>static int32 IntegerCount(const int32 IntValue, const bool Fast = true);</code>  Returns the number of characters in the int</li> </ul> <ul> <li>\u2705 <code>static int32 FloatCount(const float FloatValue, const bool Fast = true);</code>  Returns the number of characters in the float</li> </ul> <ul> <li>\u2705 <code>static int32 DecimalCount(const float FloatValue);</code>  Returns the number decimals in the float</li> </ul> <ul> <li>\u2705 <code>static uint8 BGetCloser(uint8 Ref, uint8 A, uint8 B);</code>  Returns the closer value of A and B</li> </ul> <ul> <li>\u2705 <code>static uint8 BGetFurther(uint8 Ref, uint8 A, uint8 B);</code>  Returns the further value of A and B</li> </ul> <ul> <li>\u2705 <code>static int32 IGetCloser(int32 Ref, int32 A, int32 B);</code>  Returns the closer value of A and B</li> </ul> <ul> <li>\u2705 <code>static int32 IGetFurther(int32 Ref, int32 A, int32 B);</code>  Returns the further value of A and B</li> </ul> <ul> <li>\u2705 <code>static float FGetCloser(float Ref, float A, float B);</code>  Returns the closer value of A and B</li> </ul> <ul> <li>\u2705 <code>static float FGetFurther(float Ref, float A, float B);</code>  Returns the further value of A and B</li> </ul> <ul> <li>\u2705 <code>static uint8 BGetCloserSubNum(uint8 Ref, uint8 RefA, uint8 RefB, uint8 A, uint8 B);</code>  Returns the closer value of A and B using provided numbers</li> </ul> <ul> <li>\u2705 <code>static uint8 BGetFurtherSubNum(uint8 Ref, uint8 RefA, uint8 RefB, uint8 A, uint8 B);</code>  Returns the further value of A and B using provided numbers</li> </ul> <ul> <li>\u2705 <code>static int32 IGetCloserSubNum(int32 Ref, int32 RefA, int32 RefB, int32 A, int32 B);</code>  Returns the closer value of A and B using provided numbers</li> </ul> <ul> <li>\u2705 <code>static int32 IGetFurtherSubNum(int32 Ref, int32 RefA, int32 RefB, int32 A, int32 B);</code>  Returns the further value of A and B using provided numbers</li> </ul> <ul> <li>\u2705 <code>static float FGetCloserSubNum(float Ref, float RefA, float RefB, float A, float B);</code>  Returns the closer value of A and B using provided numbers</li> </ul> <ul> <li>\u2705 <code>static float FGetFurtherSubNum(float Ref, float RefA, float RefB, float A, float B);</code>  Returns the further value of A and B using provided numbers</li> </ul> <ul> <li>\u2705 <code>static void CloserByteArray(const uint8 ByteRefValue, const TArray&lt;uint8&gt;&amp; ByteArray, const bool NotEqual, int32&amp; IndexOfCloserValue, uint8&amp; CloserValue);</code>  Returns the closer byte in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void FurtherByteArray(const uint8 ByteRefValue, const TArray&lt;uint8&gt;&amp; ByteArray, int32&amp; IndexOfFurtherValue, uint8&amp; FurtherValue);</code>  Returns the further byte in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void CloserIntegerArray(const int32 IntRefValue, const TArray&lt;int32&gt;&amp; IntArray, const bool NotEqual, int32&amp; IndexOfCloserValue, int32&amp; CloserValue);</code>  Returns the closer integer in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void FurtherIntegerArray(const int32 IntRefValue, const TArray&lt;int32&gt;&amp; IntArray, int32&amp; IndexOfFurtherValue, int32&amp; FurtherValue);</code>  Returns the further integer in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void CloserFloatArray(const float FloatRefValue, const TArray&lt;float&gt;&amp; FloatArray, const bool NotEqual, int32&amp; IndexOfCloserValue, float&amp; CloserValue);</code>  Returns the closer float in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void FurtherFloatArray(const float FloatRefValue, const TArray&lt;float&gt;&amp; FloatArray, int32&amp; IndexOfFurtherValue, float&amp; FurtherValue);</code>  Returns the further float in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void MinByteArray(const TArray&lt;uint8&gt;&amp; ByteArray, const int32 NumberOfIndexToDiscard, int32&amp; IndexOfMinValue, float&amp; MinValue);</code>  Returns the min byte in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void MaxByteArray(const TArray&lt;uint8&gt;&amp; ByteArray, const int32 NumberOfIndexToDiscard, int32&amp; IndexOfMaxValue, float&amp; MaxValue);</code>  Returns the max byte in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void MinIntegerArray(const TArray&lt;int32&gt;&amp; IntArray, const int32 NumberOfIndexToDiscard, int32&amp; IndexOfMinValue, float&amp; MinValue);</code>  Returns the min integer in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void MaxIntegerArray(const TArray&lt;int32&gt;&amp; IntArray, const int32 NumberOfIndexToDiscard, int32&amp; IndexOfMaxValue, float&amp; MaxValue);</code>  Returns the max integer in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void MinFloatArray(const TArray&lt;float&gt;&amp; FloatArray, const int32 NumberOfIndexToDiscard, int32&amp; IndexOfMinValue, float&amp; MinValue);</code>  Returns the min float in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u2705 <code>static void MaxFloatArray(const TArray&lt;float&gt;&amp; FloatArray, const int32 NumberOfIndexToDiscard, int32&amp; IndexOfMaxValue, float&amp; MaxValue);</code>  Returns the max float in the array and their index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.</li> </ul> <ul> <li>\u274c <code>return T();</code>  Returns closer value in a generic way Returns further value in a generic way Closer number to given of Array @param    Array of templated type @param  Reference value templated type to compare @param    Optional boolean to search only the closer values and no the equals @param  Optional pointer for returning the index of the closer element, if multiple closer elements the first index is returned @return The closer value found in the array or default value if the array was empty or can't find a correct value</li> </ul> <ul> <li>\u274c <code>return T();</code>  Further number to given of Array @param    Array of templated type @param  Reference value templated type to compare @param    Optional pointer for returning the index of the further element, if multiple further elements the first index is returned @return   The further value found in the array or default value if the array was empty</li> </ul> <ul> <li>\u274c <code>return TT();</code>  Closer number to given of Array @param Array of templated type @param  Reference value templated type to compare @param    Optional boolean to search only the closer values and no the equals @param  Optional pointer for returning the index of the closer element, if multiple closer elements the first index is returned @return The closer value found in the array or default value if the array was empty or can't find a correct value</li> </ul>"},{"location":"purpleprint/core/api/purpleprint-core-math.html#classstruct-upurpleprintcoremath","title":"Class/Struct: UPurpleprintCoreMath","text":"<ul> <li> <p><code>T CurCloser = ((Reference - Values[0]) &gt;= (T)0) ? (Reference - Values[0]) : -(Reference - Values[0]);</code></p> </li> <li> <p><code>int32 CurCloserIndex = 0;</code></p> </li> <li> <p><code>T CurFurther = ((Reference - Values[0]) &gt;= (T)0) ? (Reference - Values[0]) : -(Reference - Values[0]);</code></p> </li> <li> <p><code>int32 CurFurtherIndex = 0;</code></p> </li> <li> <p><code>TArray&lt;T&gt; keysArray;</code></p> </li> <li> <p><code>TArray&lt;TT&gt; valuesArray;</code></p> </li> <li> <p><code>T curCloser = ((Reference - keysArray[0]) &gt;= (T)0) ? (Reference - keysArray[0]) : -(Reference - keysArray[0]);</code></p> </li> </ul> <p>_Values  </p> <ul> <li><code>int32 curCloserIndex = 0;</code></li> </ul>"},{"location":"purpleprint/core/api/purpleprint-core-misc-editor.html","title":"PurpleprintCoreMiscEditor.h","text":""},{"location":"purpleprint/core/api/purpleprint-core-misc-editor.html#classstruct-upurpleprintcoremisceditor-inherits-from-ublueprintfunctionlibrary","title":"Class/Struct: UPurpleprintCoreMiscEditor (inherits from UBlueprintFunctionLibrary)","text":"<ul> <li>\u2705 <code>static FTransform GetEditorActiveCameraTransform();</code> </li> </ul> <ul> <li>\u2705 <code>static FVector GetEditorActiveCameraLocation();</code> </li> </ul> <ul> <li>\u2705 <code>static FRotator GetEditorActiveCameraRotation();</code> </li> </ul>"},{"location":"purpleprint/core/api/purpleprint-core-misc.html","title":"PurpleprintCoreMisc.h","text":""},{"location":"purpleprint/core/api/purpleprint-core-misc.html#classstruct-upurpleprintcoremisc-inherits-from-ublueprintfunctionlibrary","title":"Class/Struct: UPurpleprintCoreMisc (inherits from UBlueprintFunctionLibrary)","text":"<ul> <li>\u2705 <code>static EPurpleCoreAxis PurpleCoreAlignAxisToAxis(EPurpleCoreAlignAxis Align);</code> </li> </ul> <ul> <li>\u2705 <code>static EPurpleCoreAlignAxis PurpleCoreAxisToAlignAxis(EPurpleCoreAxis Axis);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector GetAxisVectorFromTransform(const FTransform&amp; Transform, EPurpleCoreAxis Align);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector GetAlignVectorFromTransform(const FTransform&amp; Transform, EPurpleCoreAlignAxis Align);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector2D FloatSplitToVector2D( const float FloatValue );</code>  Returns FVector2D(A,B) from a float A.B</li> </ul> <ul> <li>\u2705 <code>static FVector FloatSplitToVector( const float FloatValue );</code>  Returns FVector(A,B,0) from a float A.B</li> </ul> <ul> <li>\u2705 <code>static FVector4 FloatSplitToVector4( const float FloatValue );</code>  Returns FVector4(A,B,0,0) from a float A.B</li> </ul> <ul> <li>\u2705 <code>static FVector2D ClampVector2D(FVector2D Value, FVector2D Min, FVector2D Max);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector ClampVector(FVector Value, FVector Min, FVector Max);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector4 ClampVector4(FVector4 Value, FVector4 Min, FVector4 Max);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector2D VectorToVector2D( const FVector &amp;VecValue );</code>  Returns FVector2D(A,B) from the FVector(A,B,C)</li> </ul> <ul> <li>\u2705 <code>static FVector2D Vector4ToVector2D( const FVector4 &amp;Vec4Value );</code>  Returns FVector2D(A,B) from the FVector4(A,B,C,D)</li> </ul> <ul> <li>\u2705 <code>static FVector VectorIntToVector( const FIntVector &amp;VecIntValue );</code>  Returns FVector(A,B,0) from the FVector2D(A,B)</li> </ul> <ul> <li>\u2705 <code>static FVector Vector2DToVector( const FVector2D &amp;Vec2Value );</code>  Returns FVector(A,B,0) from the FVector2D(A,B)</li> </ul> <ul> <li>\u2705 <code>static FVector Vector4ToVector( const FVector4 &amp;Vec4Value );</code>  Returns FVector(A,B,C) from the FVector4(A,B,C,D)</li> </ul> <ul> <li>\u2705 <code>static FIntVector VectorToVectorInt( const FVector &amp;VecValue );</code>  Returns FVector(A,B,0) from the FVector2D(A,B)</li> </ul> <ul> <li>\u2705 <code>static FVector4 Vector2DToVector4( const FVector2D &amp;Vec2Value );</code>  Returns FVector4(A,B,0,0) from the FVector2D(A,B)</li> </ul> <ul> <li>\u2705 <code>static FVector4 VectorToVector4( const FVector &amp;VecValue );</code>  Returns FVector4(A,B,C,0) from the FVector(A,B,C)</li> </ul> <ul> <li>\u2705 <code>static FRotator RotatorOrderInvert( const FRotator &amp;RotValue );</code>  Returns FRotator(C,B,A) from the FRotator(A,B,C)</li> </ul> <ul> <li>\u2705 <code>static FVector2D Vector2DOrderInvert( const FVector2D &amp;Vec2Value );</code>  Returns FVector2D(B,A) from the FVector2D(A,B)</li> </ul> <ul> <li>\u2705 <code>static FVector VectorOrderInvert( const FVector &amp;VecValue );</code>  Returns FVector(C,B,A) from the FVector(A,B,C)</li> </ul> <ul> <li>\u2705 <code>static FVector4 Vector4OrderInvert( const FVector4 &amp;Vec4Value );</code>  Returns FVector4(D,C,B,A) from the FVector4(A,B,C,D)</li> </ul> <ul> <li>\u2705 <code>static FRotator RotatorOrderRight( const FRotator &amp;RotValue );</code>  Returns FRotator(C,A,B) from the FRotator(A,B,C)</li> </ul> <ul> <li>\u2705 <code>static FVector VectorOrderRight( const FVector &amp;VecValue );</code>  Returns FVector(C,A,B) from the FVector(A,B,C)</li> </ul> <ul> <li>\u2705 <code>static FVector4 Vector4OrderRight( const FVector4 &amp;Vec4Value );</code>  Returns FVector(D,A,B,C) from the FVector(A,B,C)</li> </ul> <ul> <li>\u2705 <code>static FRotator RotatorOrderLeft( const FRotator &amp;RotValue );</code>  Returns FRotator(B,C,A) from the FRotator(A,B,C)</li> </ul> <ul> <li>\u2705 <code>static FVector VectorOrderLeft( const FVector &amp;VecValue );</code>  Returns FVector(B,C,A) from the FVector(A,B,C)</li> </ul> <ul> <li>\u2705 <code>static FVector4 Vector4OrderLeft( const FVector4 &amp;Vec4Value );</code>  Returns FVector(B,C,D,A) from the FVector(A,B,C,D)</li> </ul> <ul> <li>\u2705 <code>static uint8 GetByteArrayAlpha(const TArray&lt;uint8&gt;&amp; Array, const float Alpha);</code>  Given an Alpha value get the aprox value in the array</li> </ul> <ul> <li>\u2705 <code>static int32 GetIntegerArrayAlpha(const TArray&lt;int32&gt;&amp; Array, const float Alpha);</code>  Given an Alpha value get the aprox value in the array</li> </ul> <ul> <li>\u2705 <code>static float GetFloatArrayAlpha(const TArray&lt;float&gt;&amp; Array, const float Alpha);</code>  Given an Alpha value get the aprox value in the array</li> </ul> <ul> <li>\u2705 <code>static FVector2D GetVector2DArrayAlpha(const TArray&lt;FVector2D&gt;&amp; Array, const float Alpha);</code>  Given an Alpha value get the aprox value in the array</li> </ul> <ul> <li>\u2705 <code>static FVector GetVectorArrayAlpha(const TArray&lt;FVector&gt;&amp; Array, const float Alpha);</code>  Given an Alpha value get the aprox value in the array</li> </ul> <ul> <li>\u2705 <code>static FRotator GetRotatorArrayAlpha(const TArray&lt;FRotator&gt;&amp; Array, const float Alpha);</code>  Given an Alpha value get the aprox value in the array</li> </ul> <ul> <li>\u2705 <code>static FTransform GetTransformArrayAlpha(const TArray&lt;FTransform&gt;&amp; Array, const float Alpha);</code>  Given an Alpha value get the aprox value in the array</li> </ul> <ul> <li>\u2705 <code>static FTransform GetTransformArrayAlphaLerp(const TArray&lt;FTransform&gt;&amp; Array, const float Alpha, const bool bLoop = false);</code>  Given an Alpha value get the aprox value in the array</li> </ul> <ul> <li>\u2705 <code>static FVector GetActiveCameraLocation(const UObject* WorldContextObject, FRotator&amp; Rotation);</code> </li> </ul> <ul> <li>\u2705 <code>static AActor* SpawnActorClone(AActor* Actor, const FTransform&amp; Transform);</code> </li> </ul> <ul> <li>\u2705 <code>static void CopySceneComponentParams(USceneComponent* Source, USceneComponent* Target);</code> </li> </ul> <ul> <li>\u2705 <code>static void CopyPrimitiveComponentParams(UPrimitiveComponent* Source, UPrimitiveComponent* Target, bool bCopyMaterials = true);</code> </li> </ul> <ul> <li>\u2705 <code>static void CopyStaticMeshComponentParams(UStaticMeshComponent* Source, UStaticMeshComponent* Target);</code> </li> </ul> <ul> <li>\u2705 <code>static void CopyDecalComponentParams(UDecalComponent* Source, UDecalComponent* Target);</code> </li> </ul> <ul> <li>\u2705 <code>static void CopyNiagaraComponentParams(UNiagaraComponent* Source, UNiagaraComponent* Target);</code> </li> </ul> <ul> <li>\u2705 <code>static void CopyParticleComponentParams(UParticleSystemComponent* Source, UParticleSystemComponent* Target);</code> </li> </ul> <ul> <li>\u2705 <code>static bool IsValidCollisionProfileName(FName ProfileName);</code> </li> </ul> <ul> <li>\u2705 <code>static TArray&lt;FName&gt; GetAllCollisionProfileNames();</code>  This function is editor only</li> </ul> <ul> <li>\u2705 <code>static bool SetPrimitiveComponentMaterials(UPrimitiveComponent* Component, TArray&lt;UMaterialInterface*&gt; Materials);</code> </li> </ul> <ul> <li>\u2705 <code>static bool SetActorStaticMeshMaterials(AStaticMeshActor* Actor, TArray&lt;UMaterialInterface*&gt; Materials);</code> </li> </ul>"},{"location":"purpleprint/core/api/purpleprint-core-misc.html#classstruct-fpurpletracestruct","title":"Class/Struct: FPurpleTraceStruct","text":"<ul> <li> <p><code>FVector Origin = FVector::ZeroVector;</code></p> </li> <li> <p><code>float Length = 200.f;</code></p> </li> <li> <p><code>EPurpleCoreAxis Direction = EPurpleCoreAxis::eZN;</code></p> </li> <li> <p><code>FVector DirectionVector = FVector(0.f, 0.f, -1.f);</code></p> </li> </ul> <p>Alternative vector manually set  </p> <ul> <li> <p><code>TEnumAsByte&lt;ETraceTypeQuery&gt; Channel = ETraceTypeQuery::TraceTypeQuery1;</code></p> </li> <li> <p><code>bool bComplex = true;</code></p> </li> <li> <p><code>bool bIgnoreSelf = true;</code></p> </li> <li> <p><code>TArray&lt;AActor*&gt; ActorsToIgnore;</code></p> </li> <li> <p><code>bool bDebug = false;</code></p> </li> </ul>"},{"location":"purpleprint/core/api/purpleprint-core-misc.html#classstruct-fpurpletracealignstruct","title":"Class/Struct: FPurpleTraceAlignStruct","text":"<ul> <li> <p><code>FVector Origin = FVector::ZeroVector;</code></p> </li> <li> <p><code>float Length = 200.f;</code></p> </li> <li> <p><code>EPurpleCoreAlignAxis Direction = EPurpleCoreAlignAxis::eFree;</code></p> </li> <li> <p><code>FVector DirectionVector = FVector(0.f, 0.f, -1.f);</code></p> </li> </ul> <p>Alternative vector manually set  </p> <ul> <li> <p><code>TEnumAsByte&lt;ETraceTypeQuery&gt; Channel = ETraceTypeQuery::TraceTypeQuery1;</code></p> </li> <li> <p><code>bool bComplex = true;</code></p> </li> <li> <p><code>bool bIgnoreSelf = true;</code></p> </li> <li> <p><code>TArray&lt;AActor*&gt; ActorsToIgnore;</code></p> </li> <li> <p><code>bool bAlignNormal = true;</code></p> </li> <li> <p><code>FVector AlignNormalMask = FVector(0.f, 0.f, 1.f);</code></p> </li> <li> <p><code>bool bDebug = false;</code></p> </li> </ul>"},{"location":"purpleprint/core/api/purpleprint-core-platform.html","title":"PurpleprintCorePlatform.h","text":""},{"location":"purpleprint/core/api/purpleprint-core-platform.html#classstruct-upurpleprintcoreplatform-inherits-from-ublueprintfunctionlibrary","title":"Class/Struct: UPurpleprintCorePlatform (inherits from UBlueprintFunctionLibrary)","text":"<ul> <li>\u2705 <code>static FString GetObjectFullName(UObject* Object);</code> </li> </ul> <ul> <li>\u2705 <code>static FString GetSoftObjectName(TSoftObjectPtr&lt;UObject&gt; InObject);</code> </li> </ul> <ul> <li>\u2705 <code>static FName GetPersistentLevelName(class UObject* WorldContextObject);</code> </li> </ul> <ul> <li>\u2705 <code>static FName GetStreamLevelNameFromActor(AActor* Actor);</code> </li> </ul> <ul> <li>\u2705 <code>static FName GetStreamLevelNameFromReference(const TSoftObjectPtr&lt;UWorld&gt; World);</code> </li> </ul> <ul> <li>\u2705 <code>static FName GetCorrectAssetName(const FString String);</code> </li> </ul> <ul> <li>\u2705 <code>static bool IsEditorBuild();</code> </li> </ul> <ul> <li>\u2705 <code>static bool IsDebugBuild();</code> </li> </ul> <ul> <li>\u2705 <code>static bool IsDevelopmentBuild();</code> </li> </ul> <ul> <li>\u2705 <code>static bool IsShippingBuild();</code> </li> </ul> <ul> <li>\u2705 <code>static void GetPrimaryMonitorResolution(int32&amp; Width, int32&amp; Height);</code>  Returns the primary monitor resolution.</li> </ul> <ul> <li>\u2705 <code>static TArray&lt;FPurpleDisplayInfo&gt; GetMonitorsInfo();</code> </li> </ul> <ul> <li>\u2705 <code>static int32 GetMonitorsNum();</code> </li> </ul> <ul> <li>\u2705 <code>static FPurpleDisplayInfo GetPrimaryMonitorInfo();</code> </li> </ul> <ul> <li>\u2705 <code>static int32 GetPrimaryMonitorIndex();</code> </li> </ul> <ul> <li>\u2705 <code>static FString GetPrimaryMonitorName();</code> </li> </ul> <ul> <li>\u2705 <code>static bool IsIndexPrimaryMonitor(const int32 Index);</code> </li> </ul> <ul> <li>\u2705 <code>static FPurpleDisplayInfo GetMonitorInfoByIndex(const int32 Index);</code> </li> </ul> <ul> <li>\u2705 <code>static FString GetMonitorName(const int32 Index);</code> </li> </ul> <ul> <li>\u274c <code>static bool GetSupportedFullscreenResolutionsByIndex(TArray&lt;FIntPoint&gt;&amp; Resolutions, const int32 Index);</code>  FIntPoint not exposed to Blueprints sadly</li> </ul> <ul> <li>\u2705 <code>static int32 DateTimeToUnixTimeStamp(const FDateTime&amp; DateTime);</code> </li> </ul> <ul> <li>\u274c <code>static int64 DateTimeToUnixTimeStamp64(const FDateTime&amp; DateTime);</code> </li> </ul> <ul> <li>\u2705 <code>static FString GetCPUBrandName();</code> </li> </ul> <ul> <li>\u2705 <code>static FString GetCPUVendorName();</code> </li> </ul> <ul> <li>\u2705 <code>static int32 GetCPUCores();</code> </li> </ul> <ul> <li>\u2705 <code>static FString GetGPUBrandName();</code> </li> </ul> <ul> <li>\u2705 <code>static FString GetGPUDriverInfo();</code> </li> </ul> <ul> <li>\u2705 <code>static FString GetOSVersion();</code> </li> </ul> <ul> <li>\u2705 <code>static FString GetNetRoleString(const ENetRole Role);</code> </li> </ul> <ul> <li>\u274c <code>static FString GetNetModeString(const ENetMode Mode);</code>  Undefined for Blueprints so cannot be exposed</li> </ul>"},{"location":"purpleprint/core/api/purpleprint-core-platform.html#classstruct-fpurpledisplayinfo","title":"Class/Struct: FPurpleDisplayInfo","text":"<ul> <li> <p><code>FString Name;</code></p> </li> <li> <p><code>FString ID;</code></p> </li> <li> <p><code>int32 NativeWidth = 0;</code></p> </li> <li> <p><code>int32 NativeHeight = 0;</code></p> </li> <li> <p><code>FIntPoint MaxResolution = FIntPoint(ForceInitToZero);</code></p> </li> <li> <p><code>bool bIsPrimary = false;</code></p> </li> <li> <p><code>int32 DPI = 0;</code></p> </li> </ul>"},{"location":"purpleprint/core/api/purpleprint-core-random.html","title":"PurpleprintCoreRandom.h","text":""},{"location":"purpleprint/core/api/purpleprint-core-random.html#classstruct-upurpleprintcorerandom-inherits-from-ublueprintfunctionlibrary","title":"Class/Struct: UPurpleprintCoreRandom (inherits from UBlueprintFunctionLibrary)","text":"<ul> <li>\u2705 <code>static int32 GetRandomIndexByWeight( const TArray&lt;float&gt; Weights);</code>  Returns a pseudo - random integer index based on weights.</li> </ul> <ul> <li>\u2705 <code>static int32 GetRandomIndexByWeightStream(FRandomStream const&amp; Stream, const TArray&lt;float&gt; Weights);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector RandomVector(FVector Min, FVector Max);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector RandomVectorStream(FRandomStream const&amp; Stream, FVector Min, FVector Max);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector RandomVectorBox(FBox Range);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector RandomVectorBoxStream(FRandomStream const&amp; Stream, FBox Range);</code> </li> </ul> <ul> <li>\u2705 <code>static FRotator RandomRotatorBox(FBox Range);</code> </li> </ul> <ul> <li>\u2705 <code>static FRotator RandomRotatorBoxStream(FRandomStream const&amp; Stream, FBox Range);</code> </li> </ul> <ul> <li>\u2705 <code>static int32 RandomRange(FInt32Range Range);</code> </li> </ul> <ul> <li>\u2705 <code>static int32 RandomRangeStream(FRandomStream const&amp; Stream, FInt32Range Range);</code> </li> </ul> <ul> <li>\u2705 <code>static float RandomFloatRange(FFloatRange Range);</code> </li> </ul> <ul> <li>\u2705 <code>static float RandomFloatRangeStream(FRandomStream const&amp; Stream, FFloatRange Range);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector2D GetRandomPointInCircle(const float Radius = 100.f, const float InnerRadius = 0.0f);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector2D GetRandomPointInCircleStream(FRandomStream const&amp; Stream, const float Radius = 100.f, const float InnerRadius = 0.0f);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector GetRandomPointInSphere(const float Radius = 100.f, const bool bAlt = false, const FVector Location = FVector::ZeroVector);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector GetRandomPointInSphereStream(FRandomStream const&amp; Stream, const float Radius = 100.f, const bool bAlt = false, const FVector Location = FVector::ZeroVector);</code> </li> </ul> <ul> <li>\u2705 <code>static FVector GetRandomPointInBoundingBoxStream(FRandomStream const&amp; Stream, const FVector Origin, const FVector BoxExtent);</code> </li> </ul>"},{"location":"purpleprint/core/api/actors/purpleprint-core-manager-actor.html","title":"PurpleprintCoreManagerActor.h","text":""},{"location":"purpleprint/core/api/actors/purpleprint-core-manager-actor.html#classstruct-apurpleprintcoremanageractor-inherits-from-aactor","title":"Class/Struct: APurpleprintCoreManagerActor (inherits from AActor)","text":"<ul> <li>\u2705 <code>virtual void SetSeed(int32 Seed);</code>  Utility</li> </ul> <ul> <li>\u2705 <code>virtual void GenerateRandomSeed();</code> </li> </ul> <ul> <li>\u274c <code>virtual void TickEditor(float DeltaTime);</code>  Called every frame</li> </ul>"},{"location":"purpleprint/core/api/actors/purpleprint-core-manager-actor.html#classstruct-apurpleprintcoremanageractor","title":"Class/Struct: APurpleprintCoreManagerActor","text":"<ul> <li><code>USceneComponent* SceneComp;</code></li> </ul> <p>Sets default values for this actor's properties  </p> <ul> <li> <p><code>UBillboardComponent* IconBB;</code></p> </li> <li> <p><code>UPurpleprintCoreManagerComponent* ManagerComp;</code></p> </li> <li> <p><code>int32 RandomSeed = 0;</code></p> </li> </ul> <p>Called when an instance of this class is placed (in editor) or spawned. @param  Transform           The transform the actor was constructed at. Allow actors to initialize themselves on the C++ side after all of their components have been initialized, only called during gameplay Called when the game starts or when spawned  </p> <ul> <li> <p><code>FRandomStream RandomStream;</code></p> </li> <li> <p><code>bool bDebug = false;</code></p> </li> </ul>"},{"location":"purpleprint/core/api/components/purpleprint-core-cable-component.html","title":"PurpleprintCoreCableComponent.h","text":""},{"location":"purpleprint/core/api/components/purpleprint-core-cable-component.html#classstruct-upurpleprintcorecablecomponent","title":"Class/Struct: UPurpleprintCoreCableComponent","text":"<ul> <li><code>FVector PreviousWorldLocation;</code></li> </ul>"},{"location":"purpleprint/core/api/components/purpleprint-core-manager-component.html","title":"PurpleprintCoreManagerComponent.h","text":""},{"location":"purpleprint/core/api/components/purpleprint-core-manager-component.html#classstruct-upurpleprintcoremanagercomponent-inherits-from-uactorcomponent","title":"Class/Struct: UPurpleprintCoreManagerComponent (inherits from UActorComponent)","text":"<ul> <li>\u274c <code>virtual void TickEditorComponent(float DeltaTime);</code> </li> </ul>"},{"location":"purpleprint/core/api/components/purpleprint-core-manager-component.html#classstruct-upurpleprintcoremanagercomponent","title":"Class/Struct: UPurpleprintCoreManagerComponent","text":"<ul> <li> <p><code>FVector WorldCameraLocation;</code></p> </li> <li> <p><code>FRotator WorldCameraRotation;</code></p> </li> </ul>"},{"location":"purpleprint/core/api/player/purpleprint-hud.html","title":"PurpleprintHUD.h","text":""},{"location":"purpleprint/core/api/player/purpleprint-hud.html#classstruct-apurpleprinthud-inherits-from-ahud","title":"Class/Struct: APurpleprintHUD (inherits from AHUD)","text":"<ul> <li>\u2705 <code>void SetControlMode(bool bInGame);</code> </li> </ul> <ul> <li>\u2705 <code>void DisplayInGameMenu(bool bDisplay, bool bMenuCall = false);</code> </li> </ul>"},{"location":"purpleprint/core/api/player/purpleprint-hud.html#classstruct-apurpleprinthud","title":"Class/Struct: APurpleprintHUD","text":"<ul> <li> <p><code>UPurpleprintUserWidget* Widget;</code></p> </li> <li> <p><code>bool bMenuUIOnly = true;</code></p> </li> </ul>"},{"location":"purpleprint/core/api/ui/purpleprint-user-widget.html","title":"PurpleprintUserWidget.h","text":""},{"location":"purpleprint/core/api/ui/purpleprint-user-widget.html#classstruct-upurpleprintuserwidget-inherits-from-uuserwidget","title":"Class/Struct: UPurpleprintUserWidget (inherits from UUserWidget)","text":"<ul> <li>\u274c <code>void DisplaySubtitles(const FText&amp; Text);</code>  Sets default values for this actor's properties Called every frame</li> </ul> <ul> <li>\u274c <code>void OnSettingsUpdate();</code>  Need to be ufunction in order to bind, runtime fail</li> </ul> <ul> <li>\u2705 <code>void DisplaySubtitlesWidget(const FText&amp; Text, const bool bVisible = false);</code> </li> </ul> <ul> <li>\u2705 <code>void SetSubtitlesInfo(const int32&amp; Size, const FLinearColor&amp; Color, const FLinearColor&amp; BackgroundColor);</code> </li> </ul> <ul> <li>\u2705 <code>void GetSubtitlesInfo(int32&amp; Size, FLinearColor&amp; Color, FLinearColor&amp; BackgroundColor);</code> </li> </ul> <ul> <li>\u2705 <code>void OnDisplayInGameMenu(bool bDisplay);</code> </li> </ul> <ul> <li>\u274c <code>virtual void OnDisplayInGameMenu_Implementation(bool bDisplay);</code> </li> </ul> <ul> <li>\u2705 <code>void ReturnToMenu();</code> </li> </ul> <ul> <li>\u274c <code>virtual void ReturnToMenu_Implementation();</code> </li> </ul> <ul> <li>\u2705 <code>void ReturnToGame();</code> </li> </ul> <ul> <li>\u274c <code>virtual void ReturnToGame_Implementation();</code> </li> </ul>"},{"location":"purpleprint/core/api/ui/purpleprint-user-widget.html#classstruct-upurpleprintuserwidget","title":"Class/Struct: UPurpleprintUserWidget","text":"<ul> <li> <p><code>int32 SubtitlesSize;</code></p> </li> <li> <p><code>FLinearColor SubtitlesColor;</code></p> </li> <li> <p><code>FLinearColor SubtitlesBackgroundColor;</code></p> </li> <li> <p><code>bool bSubtitlesEnabled = true;</code></p> </li> </ul>"},{"location":"purpleprint/path/index.html","title":"Purpleprint Path","text":"<p>Purpleprint Path specializes in spline-based mesh placement designed for creating roads, paths, and other linear infrastructure within your levels.  </p>"},{"location":"purpleprint/path/index.html#features","title":"Features:","text":"<ul> <li>Generates meshes that follow spline curves smoothly, making it easy to build roads, railways, or similar elongated elements.  </li> <li>Works similarly to the Placer tools but focuses on continuous mesh placement along splines rather than discrete objects.  </li> <li>Provides parameters to control mesh spacing, alignment, and variation for realistic and customizable results.  </li> </ul> <p>This plugin streamlines the process of creating natural and polished pathways or infrastructure elements that adapt dynamically to your level design.  </p>"},{"location":"purpleprint/placer/index.html","title":"Purpleprint Placer","text":"<p>Purpleprint Placer is a versatile placement toolset aimed at procedurally distributing actors and assets throughout your level.  </p>"},{"location":"purpleprint/placer/index.html#components","title":"Components:","text":"<ul> <li>Placer Area: Randomly places actors, static meshes, decals, and other objects within a defined area, ideal for scattering foliage, props, or decals.  </li> <li>Placer Spline: Allows placement of objects along a spline with randomization and alignment options, useful for fences, lights, or environmental details following a curved path.  </li> <li>Placer Array: Places objects in array formations with options for random offsets and rotations, perfect for more structured but varied asset placement.  </li> </ul>"},{"location":"purpleprint/placer/index.html#placement-features","title":"Placement Features:","text":"<ul> <li>Supports alignment of placed objects to walls, floors, or any surface, ensuring natural integration with the environment.  </li> <li>Provides control over density, randomness, and orientation to fit diverse design needs.  </li> </ul>"}]}